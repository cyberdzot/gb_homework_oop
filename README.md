#
# __Домашняя работа по ООП__

## ___work_01___ (на основе кода из архива)

Если честно, то проблем в таком проектировании не вижу пока что, так как впервые сталкиваюсь с ООП, может быть переопределять методы это плохо и есть решение куда правильнее...

Допустим если все животные не могут летать, то не прописывать для всех метод полёта, или не перебирать всех животных для полёта.

Чуечка конечно говорит что здесь нужно что то существеннее, но это дело времени, когда весь курс пройду тогда и пойму.


## ___work_02___ (на основе кода из архива)
...


## ___work_03___ (на основе кода с семинара)
...


## ___work_04___

Принцип работы LinkedList _понятен и прост_, то что друг за другом чередуются элементы и они знают адреса только соседей и если нужно узнать что внутри или как либо обратится к определённому элементу, то нужно бежать по всему(или почти) по всему списку, ранее когда ArrayList не был оптимизирован наверняка LinkedList выигрывал в плане воспроизведения или чтения заранее линейных каких то событий(например меню блюд которое редко обновляется и оно всегда идёт в одном порядке) и в памяти наверняка ложился LinkedList лучше(места занимал меньше и суетился меньше), а сейчас ArrayList оптимизирован глубоко под капотом и имеет больше возможностей.

"_Понятен и прост_" пока не начинаешь к нему придумывать код со стилем ООП =).

# 
> ## Примечания к ООП в Java:
> - Если переопределяем _equals()_, то по хорошему переопределяем _hashCode()_, ибо при работе с коллекциями в их результатах будет абракадабра;
> - Оператор _instanceof_ позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования;
> - Интерфейс - это поведение;